package pij.main;

import pij.main.dictionary.Dictionary;

public class WordMove extends Move {

    private static final String RACK_LETTERS_ERR =
            "You don't have the tiles.\n";
    private static final String ORIGIN_ERR =
            "Invalid starting position for your word.\n";
    private static final String PLACEMENT_ERR =
            "This move can't be placed here.\n";
    private static final String WORD_ERR =
            "The word is not valid.\n";

    private String letters;
    private Position position;
    private Direction direction;
    private String errorMsg;
    private boolean valid;

    public WordMove(String letters, Position position, Direction direction) {
        this.letters = letters;
        this.position = position;
        this.direction = direction;
        this.errorMsg = "";
    }

    /**
     * Implements Move.place(), places a given WordMove on the Board and returns
     * the score generated by that Move. This method also updates the scoring
     * mechanism of a Square after a Tile is placed on it.
     * @param board
     * @param rack
     * @return int value of the score
     */
    public int place(final Board board, final Rack rack) {
        int letterScore = 0;
        int wordMultiplier = 1;
        int bonus;
        Position position = this.position;
        String remainingLetters = this.letters;
        char letter;
        Tile tile;
        Direction direction = this.getDirection();
        while (!remainingLetters.isEmpty() || !board.isPositionFree(position)) {
            if (board.isPositionFree(position)) {
                letter = remainingLetters.charAt(0);
                tile = rack.take(letter);
                board.placeTile(position, tile);

                if (remainingLetters.length() == 1) {
                    remainingLetters = "";
                } else {
                    remainingLetters = remainingLetters.substring(1);
                }
            }
            letterScore += board.getLetterScore(position);
            wordMultiplier *= board.getWordMultiplier(position);
            board.setStandardScoring(position);

            position = position.next(direction);
        }
        bonus = this.letters.length() == Rack.RACK_SIZE ? 70 : 0;

        return (letterScore * wordMultiplier) + bonus;
    }

    /**
     * Implements Move.getLetters(), returns the letters of the Move.
     * @return String of the letters
     */
    public String getLetters() {
        return this.letters;
    }

    /**
     * Implements Move.getPosition(), returns the Position of the Move.
     * @return position
     */
    public Position getPosition() {
        return this.position;
    }

    /**
     * Implements Move.getDirection(), returns the Direction of the Move.
     * @return direction (right or down)
     */
    public Direction getDirection() {
        return this.direction;
    }

    /**
     * Implements Move.validate(), checks whether a given Move is valid by
     * checking if: the Player's rack holds the necessary Tiles, the Move has a
     * valid starting position, the Move can be placed in the given Position and
     * the Move generates a valid word.
     * @return true if Move is valid
     */
    public boolean validate(
            final Board board, final Rack rack, final Dictionary dictionary) {
        this.valid = true;
        validLetters(rack);
        validStart(board);
        validPlacement(board);
        if (this.valid) {
            validWord(dictionary, board);
        }

        return this.valid;
    }

    private void validLetters(final Rack rack) {
        if (!rack.hasLetters(this.letters)) {
            handleError(RACK_LETTERS_ERR);
        }
    }

    private void validStart(final Board board) {
        if (!board.checkStart(this)) {
            handleError(ORIGIN_ERR);
        }
    }

    private void validPlacement(final Board board) {
        if (!board.checkPlacement(this)) {
            handleError(PLACEMENT_ERR);
        }
    }

    private void validWord(final Dictionary dictionary, final Board board) {
        String word = board.getWord(this);
        if (!dictionary.contains(word)) {
            handleError(WORD_ERR);
        }
    }

    private void handleError( String errorMsg) {
        this.errorMsg += errorMsg;
        this.valid = false;
    }

    /**
     * Generates a String stating the Move.
     * @return string of the Move
     */
    public String toString() {
        String string = String.format(
                "Word: %s at position %s, direction: %s",
                this.letters, this.position, this.direction);
        return string;
    }

    /**
     * Returns the error message explaining what is wrong with a given Move.
     * @return string error message
     */
    public String getErrorMsg() {
        return this.errorMsg;
    }

    /**
     * Updates the pass counter for a given player, resetting it to zero to
     * reflect a WordMove has been played.
     * @param player whose pass counter is being updated
     */
    public void updatePassCounter(final Player player) {
        player.passCounter = 0;
    }

}
