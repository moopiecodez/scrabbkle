package pij.main;

import java.util.Arrays;

import pij.main.Move.Direction;
import pij.main.dictionary.Dictionary;

/**
 * Computer player class to play as oponent against the human user.
 *
 * @author Maurane van der Stoep
 *
 */
public class Computer extends Player {

    Move bestMove;

    public Computer(Rack rack, Dictionary dictionary) {
        super(rack, dictionary);
    }

    /**
     * Generates and returns the Move generated by the Computer player.
     * @param board
     * @return Move of Computer player
     */
    public Move chooseMove(final Board board) {
        this.bestMove = new Pass();
        for (int i = 0; i < board.getSize(); i++) {
            getMoveForArray(i, Direction.right, board);
            getMoveForArray(i, Direction.down, board);
        }

        return bestMove;
    }

    /**
     * In a given array of the Board (row or column) generates a Move.
     * @param array
     * @param direction
     * @param board
     * @return move
     */
    private Move getMoveForArray(
            final int array, final Direction direction, final Board board) {
        Move move = null;
        String rackLetters = this.rack.getLetters();

        for (int i = 0; i < board.getSize(); i++) {
            Position position = switch (direction) {
                case right -> Position.fromIndices(array, i);
                case down -> Position.fromIndices(i, array);
            };
            Move testMove = new WordMove(rackLetters, position, direction);
            boolean validStart = board.checkStart(testMove);
            if (validStart) {
                powerSetPermutations(rackLetters, position, direction, board);
                /*
                 System.out.println("Maybe I go, " + direction
                       + " here...: " + position);
                */
            }
        }

        return move;
    }

    private void evaluateMove(Move move) {
        int bestMoveLength = this.bestMove.getLetters().length();
        int moveLength = move.getLetters().length();
        if(bestMoveLength < moveLength) {
            this.bestMove = move;
        }
    }

    /**
     * Generates all the combinations from a given string.
     * @param limit
     * @param source
     * @param combi
     * @param depth
     * @param start
     */
    private void combinations(
            int limit, char[] source, char[] combi, int depth, int start,
            Position position, Direction direction, Board board) {
        if (depth == limit) {
            int length = combi.length;
            char[] permu = new char[length];
            boolean[] visited = new boolean[length];
            for (int i = 0; i < length; i++) {
                visited[i] = false;
            }
            permutations(length, combi, permu, visited, -1,
                    position, direction, board);
            return;
        }
        for (int i = start; i < source.length; i++) {
            combi[depth] = source[i];
            start++;
            depth++;
            combinations(limit, source, combi, depth, start,
                    position, direction, board);
            depth--;
        }
    }

    /**
     * Generate the powerSet permutations of a given String.
     * @param string
     */
    private void powerSetPermutations(String string,
            Position position, Direction direction, Board board) {
        char[] source = string.toCharArray();
        for (int i = 1; i <= source.length; i++) {
            char[] combi = new char[i];
            combinations(i, source, combi, 0, 0, position, direction, board);
        }
    }

    private void permutations(int length, char[] source, char[] permu,
            boolean[] visited, int depth,
            Position position, Direction direction, Board board) {
        if (depth + 1 >= length) {
            String letters = new String(permu);
            Move move = new WordMove(letters, position, direction);
            if (move.validate(board, this.rack, this.dictionary)) {
                evaluateMove(move);
            }
        }
        for (int i = 0; i < source.length; i++) {
            if (!visited[i]) {
                depth++;
                permu[depth] = source[i];
                visited[i] = true;
                permutations(length, source, permu, visited, depth,
                        position, direction, board);
                visited[i] = false;
                depth--;
            }
        }
    }
}
